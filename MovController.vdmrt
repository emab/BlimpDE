class MovController

instance variables
	motorLeft: SimpleActuator;
	motorRight: SimpleActuator;
	camController: CamController;
	pid: PID;
	
types
PID :: pGain : real
			 dGain : real
			 iGain : real
			 iMax : real
			 iMin : real
			 iState : real
			 dState : real;
	
operations

	public MovController : SimpleActuator * SimpleActuator * CamController ==> MovController
	MovController(motorL, motorR, camCont) == 
	(
	  motorLeft:= motorL; 
 		motorRight:= motorR;
 		camController:= camCont;
 		pid:= mk_PID(0.80,82,0,1,1,0,0);
  );
	
  private control_loop : () ==> ()
	control_loop() == cycles(0) (
		dcl pos:CamController`EstimatedPos:= camController.process();
		dcl coords:CamController`Coord:=pos.Coord;
		--dcl theta:real:=pos.T;
		dcl targetY:real:= 1;
		dcl drive:real;
	
		drive:=normalise(updatePID(targetY - coords.Y, coords.Y));
		motorLeft.setValue(drive);
		motorRight.setValue(drive);
  );
  
  private updatePID : real * real ==> real
  updatePID(pidError, position) ==
  (
  	dcl pTerm:real:= pidError * pid.pGain;
  	dcl dTerm:real:= pid.dGain * (position - pid.dState);
  	dcl iTerm:real;
  	dcl output:real;
  	pid.iState:= pid.iState + pidError;
  	if (pid.iState > pid.iMax) then
  	(
  		pid.iState:= pid.iMax;
  	) else if (pid.iState < pid.iMin) then
  	(
  		pid.iState:= pid.iMin;
  	);
  	iTerm:= pid.iGain * pid.iState;
		pid.dState:= position;
		output:= (pTerm + iTerm - dTerm);
		return output;
  );
  
  private normalise : real ==> real
  normalise(input) ==
  (
  	if (input > 1) then
  		return 1
  	else if (input < -1) then
  		return -1
  	else
  		return input;	
  );
	
thread

	periodic(20E6,0,0,0)(control_loop);	 
		 
end MovController
