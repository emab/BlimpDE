class MovController

instance variables
	motorLeft: SimpleActuator;
	motorRight: SimpleActuator;
	camController: CamController;
	pPid: PID;
	tPid: PID;
	target: Target;
	step: real:= 1;
	
types
PID :: pGain : real
			 dGain : real
			 dState : real;

Target :: X : real
					Y : real;
					
operations

	public MovController : SimpleActuator * SimpleActuator * CamController ==> MovController
	MovController(motorL, motorR, camCont) == 
	(
	  motorLeft:= motorL; 
 		motorRight:= motorR;
 		camController:= camCont;
 		pPid:= mk_PID(0.8,90,0);
 		tPid:= mk_PID(0.1,0,0);
 		target:= mk_Target(1,1);
  );
	
  private control_loop : () ==> ()
	control_loop() == cycles(0) (
		dcl pos:CamController`EstimatedPos:= camController.process();
		dcl coords:CamController`Coord:=pos.Coord;
		IO`printf("CALCULATED THETA:::::::::::::::::::::: %s\n",[pos.T]);
		if step = 0 then (
			dcl driveY:real:=normalise(updatePositionPID(target.Y - coords.Y, coords.Y));
			motorLeft.setValue(driveY);
			motorRight.setValue(driveY);
			if (coords.Y < target.Y + 0.0001 and coords.Y > target.Y - 0.0001) then
				step:=1;
		);
		
		if step = 1 then (
			--ROTATE DEPENDING ON THE DESIRED X COORDINATE
			dcl targetT:real;
			dcl driveT:real;
			if (target.X = 0) then
				targetT:=0
			else if (target.X > 0) then
				targetT:=-MATH`pi/2
			else if (target.X < 0) then
				targetT:=MATH`pi/2;
			driveT:=normalise(updateDirectionPID(targetT - pos.T, pos.T));
			motorLeft.setValue(driveT);
			motorRight.setValue(-driveT);
			IO`printf("TARGET T: %s      POS T: %s",[targetT*(180/MATH`pi),pos.T*(180/MATH`pi)]);
			if (pos.T < targetT + 0.0001 and pos.T > targetT - 0.0001) then
				step:=3;
		);
		if step = 2 then (
			dcl driveX:real:=normalise(updatePositionPID(target.X - coords.X, coords.X));
			motorLeft.setValue(driveX);
			motorRight.setValue(driveX);
			
			if (coords.X < target.X + 0.0001 and coords.X > target.X - 0.0001) then
				step:=3;
		);
  );
  
  private updatePositionPID : real * real ==> real
  updatePositionPID(pidError, position) ==
  (
  	dcl pTerm:real:= pidError * pPid.pGain;
  	
  	dcl dTerm:real:= pPid.dGain * (position - pPid.dState);

  	dcl output:real;
  	
		pPid.dState:= position;
		output:= (pTerm - dTerm);
		return output;
  );
  
  private updateDirectionPID : real * real ==> real
  updateDirectionPID(pidError, position) ==
  (
  	dcl pTerm:real:= pidError * tPid.pGain;
  	
  	dcl dTerm:real:= tPid.dGain * (position - tPid.dState);

  	dcl output:real;
		tPid.dState:= position;
		output:= (pTerm - dTerm);
		return output;
  );
  
  private normalise : real ==> real
  normalise(input) ==
  (
  	if (input > 1) then
  		return 1
  	else if (input < -1) then
  		return -1
  	else
  		return input;	
  );
	
thread

	periodic(20E6,0,0,0)(control_loop);	 
		 
end MovController
