class CamController

instance variables
camera: Camera;
realObjects: RealObjects;
	
types
	ObjectID = nat;
	ObjectInfo :: xCoord : real
								yCoord : real
								radius : real;
	RealObjects = map ObjectID to ObjectInfo;
	
	Test :: 
					xPixel : nat
					yPixel : nat
					width : nat;
	TestObjects = map ObjectID to Test;
	
	Coord :: X : real
					 Y : real
					 Z : real;
					 
	Length :: a : real
						b : real
						c : real;
					 
	Coord2 :: X : real
						Y : real;
	
	Lengths :: l1: real
						 l2: real
						 l3: real;

values
	calcX = 0;
	calcY = 0;
	calcZ = 0;
	calcTheta = 0;						

operations

	public CamController : Camera ==> CamController
	CamController(c) == 
	(
  	camera:= c;
  );
   
  public process : () ==> ()
  process() ==
  (
  	dcl processedObjects:Camera`ProcessedObjects:= camera.processImage();
  	dcl testObj:TestObjects;
  	if (card(dom  processedObjects) < 3) then
  	(
  		skip;
  	) else
  	(
  		dcl count:nat:= 1;
  		dcl testObj:TestObjects:= {|->};
  		dcl p1:Coord;
			dcl p2:Coord;
			dcl p3:Coord;
			dcl l1:real;
			dcl l2:real;
			dcl l3:real;
			dcl lengths:Lengths;
			dcl coords:Coord;
			dcl angle:real;
			
			for all objID in set dom processedObjects do
			(
				while count <= 3 do
				(
					testObj(objID):= mk_Test(processedObjects(objID).xPixel,processedObjects(objID).yPixel,processedObjects(objID).width);
					
					if (count = 1) then
						p1:= mk_Coord(realObjects(objID).xCoord, realObjects(objID).xCoord, 0);
						l1:= getDistance(realObjects(objID).radius, processedObjects(objID).width, camera);
					if (count = 2) then
						p2:= mk_Coord(realObjects(objID).xCoord, realObjects(objID).xCoord, 0);
						l2:= getDistance(realObjects(objID).radius, processedObjects(objID).width, camera);
					if (count = 3) then
						p3:= mk_Coord(realObjects(objID).xCoord, realObjects(objID).xCoord, 0);
						l3:= getDistance(realObjects(objID).radius, processedObjects(objID).width, camera);
				);
				count:= count + 1;
			);
			lengths:= mk_Lengths(l1,l2,l3);
			coords:= trilaterate(p1,p2,p3,lengths);
			IO`println(coords);
  	);
  ); 
  
  private getDistance : real * int * Camera ==> real
  getDistance(objR, pixelWidth, cam) ==
  (
	 	return objR / MATH`tan((((cam.getxFOV()*180/MATH`pi)*pixelWidth)/cam.getxResolution())/2);
  );
   
  private trilaterate : Coord * Coord * Coord * Lengths ==> Coord
  trilaterate(p1, p2, p3, length) ==
  (
		dcl x1:real:= p1.X;
		dcl y1:real:= p1.Y;
		dcl z1:real:= p1.Z;
		
		dcl x2:real:= p2.X;
		dcl y2:real:= p2.Y;
		dcl z2:real:= p2.Z;
	
		dcl x3:real:= p3.X;
		dcl y3:real:= p3.Y;
		dcl z3:real:= p3.Z;
		
		dcl L1:real:= length.l1;
		dcl L2:real:= length.l2;
		dcl L3:real:= length.l3;
		
		dcl LB1:real:= MATH`sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));
		dcl LB2:real:= MATH`sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2) + (z3 - z2) * (z3 - z2));
		dcl LB3:real:= MATH`sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3) + (z1 - z3) * (z1 - z3));
		
		dcl X:real:= (L1*L1  - L2*L2  + LB1*LB1)/(2*LB1 );
		dcl C1:real:= MATH`sqrt(L1*L1 - X*X);
		dcl XB:real:= (LB3*LB3 - LB2*LB2 + LB1*LB1 )/(2*LB1);
		dcl CB:real:= MATH`sqrt(LB3*LB3 - XB* XB );
		dcl D1:real:= MATH`sqrt(C1*C1+(XB - X)*(XB - X));
		dcl Y:real:= (D1*D1 - L3*L3  + CB*CB  )/(2*CB );
		dcl Z:real:= MATH`sqrt(C1 * C1 - Y * Y);
		
		dcl Xx:real:= (x2-x1);
		dcl Xy:real:= (y2-y1);
		dcl Xz:real:= (z2-z1);
		dcl Xl:real:= MATH`sqrt(Xx*Xx+Xy*Xy+Xz*Xz);
		
		dcl t:real:= -((x1-x3)*(x2-x1)+(y1-y3)*(y2-y1)+(z1-z3)*(z2-z1))/(LB1*LB1);
		dcl Yx:real:= (x1+(x2-x1)*t-x3);
	  dcl Yy:real:= (y1+(y2-y1)*t-y3);
	  dcl Yz:real:= (z1+(z2-z1)*t-z3);
	  dcl Yl:real:= MATH`sqrt(Yx*Yx+Yy*Yy+Yz*Yz);
	    
	  dcl Zx:real:= (Xy * Yz - Xz * Yy);
	  dcl Zy:real:= (Xz * Yx - Xx * Yz);
	  dcl Zz:real:= (Xx * Yy - Xy * Yx);  
	    
		Xx:= Xx / Xl;
		Xy:= Xy / Xl;
		Xz:= Xz / Xl;
		
		Yx:= - (Yx/Yl);
	  Yy:= - (Yy/Yl);
	  Yz:= - (Yz/Yl);
      
    return mk_Coord((x1 + X * Xx + Y * Yx + Z * Zx),(y1 + X * Xy + Y * Yy + Z * Zy),(z1 + X * Xz + Y * Yz + Z * Zz));
	);
   
  private calcAngle : RealObjects  * Camera * Coord ==> real
  calcAngle(realObj, cam, coords) ==
  (
		dcl resX:real:= cam.getxResolution();
		dcl resY:real:= cam.getyResolution();
		dcl xFOV:real:= cam.getxFOV();
		dcl yFOV:real:= cam.getyFOV();
		dcl xCam:real:= coords.X;
		dcl yCam:real:= coords.Y;
		dcl zCam:real:= coords.Z;
		
		dcl xMax:real:= zCam * MATH`tan((xFOV/2)*(180/MATH`pi));
		dcl yMax:real:= zCam * MATH`tan((yFOV/2)*(180/MATH`pi));  	
		
		dcl avgXPixelVal:real:= resX/(2*xMax);
		dcl avgYPixelVal:real:= resY/(2*yMax);
   	
   	dcl obj1:Coord2:= Translate(xCam, yCam, realObj(1).xCoord, realObj(1).yCoord);
   	--dcl obj2:Coord2:= Translate(xCam, yCam, o2r.xCoord, o2r.yCoord);   	
   	--dcl obj3:Coord2:= Translate(xCam, yCam, o3r.xCoord, o3r.yCoord);
   	
   	--dcl obj1x:int:= floor ((obj1.X - pixelOriginX) * avgXPixelVal);
   	--dcl obj1y:int:= floor ((obj1.Y - pixelOriginY) * avgYPixelVal);  
    --dcl obj2x:int:= floor ((obj2.X - pixelOriginX) * avgXPixelVal);  
   	--dcl obj2y:int:= floor ((obj2.Y - pixelOriginY) * avgYPixelVal);  
   	--dcl obj3x:int:= floor ((obj3.X - pixelOriginX) * avgXPixelVal);  
   	--dcl obj3y:int:= floor ((obj3.Y - pixelOriginY) * avgYPixelVal);     	
   	
   	--dcl calcangle1:real:= angleChange(obj1x, obj1y, o1.xPixel, o1.yPixel, resX/2, resY/2);
   	--dcl calcangle2:real:= angleChange(obj1x, obj1y, o2.xPixel, o2.yPixel, resX/2, resY/2);
   	--dcl calcangle3:real:= angleChange(obj1x, obj1y, o3.xPixel, o3.yPixel, resX/2, resY/2);
		
		--return abs ((calcangle1 + calcangle2+ calcangle3)/2);   
   	return 0;
   );
   
  private Translate : real * real * real * real ==> Coord2
  Translate(xCam, yCam, x, y) ==
  (
	 	dcl adjX:real;
	 	dcl adjY:real;
	 	dcl translated:Coord2;
   	
	 	if ((xCam > 0 and yCam > 0) or (xCam > 0 and yCam < 0) or (xCam > 0 and yCam = 0) or (xCam = 0 and yCam > 0)) then
			(
				adjX:= x - xCam;
				adjY:= y - yCam;
	 		) else if ((xCam < 0 and yCam < 0) or (xCam = 0 and yCam < 0)) then
	 		(
				adjX:= x - xCam;
				adjY:= y + yCam;	
	  	) else if (xCam < 0 and yCam >= 0) then
	  	(
	  		adjX:= x + xCam;
				adjY:= y + yCam;
			) else if (xCam = 0 and yCam = 0) then
			(
				adjX:= x;
				adjY:= y;
			);
		
		translated:= mk_Coord2(adjX, adjY);
		
 		return translated;
  );

	private readCSV : seq1 of char ==> RealObjects
  readCSV(file) ==
  (
  let mk_(ok, lines) = CSV`flinecount(file)
  in
  	if ok then (
  		dcl objects : map ObjectID to ObjectInfo := {|->};
  		for i = 1 to lines do
  			let mk_(ok, [objectid, xcoord, ycoord, radius]) = CSV`freadval[seq of real](file,i)
  			in objects(objectid) := mk_ObjectInfo(xcoord, ycoord, radius);
  			return objects;
  			)
  			else error;
  ); 
		 
end CamController
